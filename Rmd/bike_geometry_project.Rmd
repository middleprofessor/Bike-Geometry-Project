---
title: "Bike Geometry Project"
author: "Jeffrey Walker"
date: "`r Sys.Date()`"
output: html_document
---

# Setup

```{r setup, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE,
                      warning = FALSE,
                      knitr.kable.NA = '')
# wrangling packages
library(here) # here makes a project transportable
library(janitor) # clean_names
library(readxl) # read excel, duh!
library(data.table) # magical data frames
library(magrittr) # pipes
library(stringr) # string functions
library(forcats) # factor functions

# analysis packages
library(emmeans) # the workhorse for inference
library(nlme) # gls and some lmm
library(lme4) # linear mixed models
library(lmerTest) # linear mixed model inference
library(afex) # ANOVA linear models
library(glmmTMB) # generalized linear models
library(MASS) # negative binomial and some other functions
library(car) # model checking and ANOVA
library(DHARMa) # model checking
library(mvtnorm)

# graphing packages
library(ggsci) # color palettes
library(ggpubr) # publication quality plots
library(ggforce) # better jitter
library(cowplot) # combine plots
library(knitr) # kable tables
library(kableExtra) # kable_styling tables
library(ggdendro) # dendrogram
library(dendextend) # better dendrogram
library(ggiraph)
library(GGally)

# ggplot_the_model.R packages not loaded above
library(insight)
library(lazyWeave)

# use here from the here package
here <- here::here
# use clean_names from the janitor package
clean_names <- janitor::clean_names
# use transpose from data.table
transpose <- data.table::transpose

# load functions used by this text written by me
# ggplot_the_model.R needs to be in the folder "R"
# if you didn't download this and add to your R folder in your
# project, then this line will cause an error
#source_path <- here("R", "ggplot_the_model.R")
#source(source_path)

data_folder <- "data"
image_folder <- "images"
output_folder <- "output"

pal_okabe_ito <- c(
  "#E69F00",
  "#56B4E9",
  "#009E73",
  "#F0E442",
  "#0072B2",
  "#D55E00",
  "#CC79A7"
)
pal_okabe_ito_blue <- pal_okabe_ito[c(5,6,1,2,3,7,4)] 
pal_okabe_ito_red <- pal_okabe_ito[c(6,5,3,1,2,7,4)] 
pal_okabe_ito_2 <- pal_okabe_ito[c(5,6)]
pal_okabe_ito_3 <- pal_okabe_ito[c(5,6,7)]
pal_okabe_ito_3_light <- pal_okabe_ito[c(1,2,7)]
pal_okabe_ito_4 <- pal_okabe_ito[c(5,6,7,2)]

```

# Functions

## General

```{r deg_2_rad}
deg_2_rad <- function(x){
  rad <- x*pi/180
  return(rad)
}
  
```

## Dendrogram

```{r ggdendro-extensions}
# https://atrebas.github.io/post/2019-06-08-lightweight-dendrograms/
dendro_data_k <- function(hc, k) {
  hcdata    <-  ggdendro::dendro_data(hc, type = "rectangle")
  seg       <-  hcdata$segments
  labclust  <-  cutree(hc, k)[hc$order]
  segclust  <-  rep(0L, nrow(seg))
  heights   <-  sort(hc$height, decreasing = TRUE)
  height    <-  mean(c(heights[k], heights[k - 1L]), na.rm = TRUE)
  
  for (i in 1:k) {
    xi      <-  hcdata$labels$x[labclust == i]
    idx1    <-  seg$x    >= min(xi) & seg$x    <= max(xi)
    idx2    <-  seg$xend >= min(xi) & seg$xend <= max(xi)
    idx3    <-  seg$yend < height
    idx     <-  idx1 & idx2 & idx3
    segclust[idx] <- i
  }
  
  idx                    <-  which(segclust == 0L)
  segclust[idx]          <-  segclust[idx + 1L]
  hcdata$segments$clust  <-  segclust
  hcdata$segments$line   <-  as.integer(segclust < 1L)
  hcdata$labels$clust    <-  labclust
  
  hcdata
}

set_labels_params <- function(nbLabels,
                              direction = c("tb", "bt", "lr", "rl"),
                              fan       = FALSE) {
  if (fan) {
    angle       <-  360 / nbLabels * 1:nbLabels + 90
    idx         <-  angle >= 90 & angle <= 270
    angle[idx]  <-  angle[idx] + 180
    hjust       <-  rep(0, nbLabels)
    hjust[idx]  <-  1
  } else {
    angle       <-  rep(0, nbLabels)
    hjust       <-  0
    if (direction %in% c("tb", "bt")) { angle <- angle + 45 }
    if (direction %in% c("tb", "rl")) { hjust <- 1 }
  }
  list(angle = angle, hjust = hjust, vjust = 0.5)
}

plot_ggdendro <- function(hcdata,
                          direction   = c("lr", "rl", "tb", "bt"),
                          fan         = FALSE,
                          scale.color = NULL,
                          branch.size = 1,
                          label.size  = 3,
                          nudge.label = 0.01,
                          expand.y    = 0.1) {
  

  direction <- match.arg(direction) # if fan = FALSE
  ybreaks   <- pretty(segment(hcdata)$y, n = 5)
  ymax      <- max(segment(hcdata)$y)
  
  ## branches
  p <- ggplot() +
    geom_segment(data         =  segment(hcdata),
                 aes(x        =  x,
                     y        =  y,
                     xend     =  xend,
                     yend     =  yend,
                     linetype =  factor(line),
                     colour   =  factor(clust)),
                 lineend      =  "round",
                 show.legend  =  FALSE,
                 size         =  branch.size)
  
  ## orientation
  if (fan) {
    p <- p +
      coord_polar(direction = -1) +
      scale_x_continuous(breaks = NULL,
                         limits = c(0, nrow(label(hcdata)))) +
      scale_y_reverse(breaks = ybreaks)
  } else {
    p <- p + scale_x_continuous(breaks = NULL)
    if (direction %in% c("rl", "lr")) {
      p <- p + coord_flip()
    }
    if (direction %in% c("bt", "lr")) {
      p <- p + scale_y_reverse(breaks = ybreaks)
    } else {
      p <- p + scale_y_continuous(breaks = ybreaks)
      nudge.label <- -(nudge.label)
    }
  }
  
  # labels
  labelParams <- set_labels_params(nrow(hcdata$labels), direction, fan)
  hcdata$labels$angle <- labelParams$angle
  
  p <- p +
    geom_text(data        =  label(hcdata),
              aes(x       =  x,
                  y       =  y,
                  label   =  label,
                  colour  =  factor(clust),
                  angle   =  angle),
              vjust       =  labelParams$vjust,
              hjust       =  labelParams$hjust,
              nudge_y     =  ymax * nudge.label,
              size        =  label.size,
              show.legend =  FALSE)
  
  # theme
    # p <- p + theme_pubr() +
    #   theme(axis.text.x=element_blank())
  
  # colors and limits
  if (!is.null(scale.color)) {
    scale.color <- c("#000000", scale.color) #my addition
    p <- p + scale_color_manual(values = scale.color)
  }
  
  ylim <- -round(ymax * expand.y, 1)
  p    <- p + expand_limits(y = ylim)

  
  p
}

```

```{r treed}
get_tree <- function(geobike_subset,
                  y_cols,
                  scale_it = TRUE,
                  center_it = TRUE,
                  hclust_method = "ward.D2"
){
  # dd <- dist(scale(geobike_subset[, .SD, .SDcols = y_cols],
  #                  center = center_it,
  #                  scale = scale_it),
  #            method = "euclidean")
  # dendro <- hclust(dd, method = hclust_method) %>%
  #   as.dendrogram() %>%
  #   place_labels(paste(geobike_subset[, model],
  #                      geobike_subset[, frame_size],
  #                      sep = ", "))
  
  cluster_data <- geobike_subset[, .SD, .SDcols = y_cols] %>%
    data.frame
  row.names(cluster_data) <- paste(geobike_subset[, model],
                                   geobike_subset[, frame_size],
                                   sep = ", ")
  d_matrix <- dist(scale(cluster_data,
                         center = center_it,
                         scale = scale_it),
                   method = "euclidean")
  hc <- hclust(d_matrix, method = hclust_method)
  return(hc)
  
}
```

## Bike geometry helpers

```{r bike-geometry-helpers}
compute_axle_crown <- function(){
  
}

compute_chainstay_h <- function(bike){
  # the horizontal component of chainstay length 
  # bbd = bottom bracket drop
  # csl = chainstay length
  chainstay_h <- with(bike,
                      sqrt(chainstay_length^2 - bottom_bracket_drop^2))
  return(chainstay_h)
}


compute_offset_h <- function(bike){
  # the horizontal component of fork offset
  offset_h <- with(bike,
                 fork_offset_rake/sin(deg_2_rad(head_tube_angle)))
  return(offset_h)
}

compute_head_tube_h <- function(bike){
  # the horizontal component of head_tube
  head_tube_h <- with(bike,
               head_tube_length*cos(deg_2_rad(head_tube_angle)))
  return(head_tube_h)
}
compute_head_tube_v <- function(bike){
  # the vertical component of head_tube
  head_tube_v <- with(bike,
                      head_tube_length*sin(deg_2_rad(head_tube_angle)))
  return(head_tube_v)
}

compute_fork_angle <- function(bike){
  # angle of fork axle-crown axis to horizontal
  # beta is angle of fork axle-crow to offset line
  beta <- with(bike,
               acos(fork_offset_rake/axle_crown)*180/pi)
  # delta is angle from offset line to horizontal
  delta <- with(bike,
                90 - head_tube_angle)
  fork_angle <- beta - delta
  return(fork_angle)
}

compute_steering_v <- function(bike){
  # steering_v is the vertical component of the steering axis from top of head tube
  # to the horizontal line through wheel axles - so height from axle to head tube crown
  steering_v <- with(bike,
                     stack - bottom_bracket_drop)
  return(steering_v)
}

compute_steering_h <- function(bike){
  steering_v <- compute_steering_v(bike)
  steering_h <- with(bike,
                     steering_v/tan(deg_2_rad(head_tube_angle)))
  return(steering_h)
}

```

## Compute missing data

```{r missing data}
compute_wheelbase <- function(bike){
  steering_v <- compute_steering_v(bike)
  steering_h <- compute_steering_h(bike)
  offset_h <- compute_offset_h(bike)
  chainstay_h <- compute_chainstay_h(bike)
  wheelbase <- with(bike,
                    chainstay_h + reach + steering_h + offset_h)
  return(wheelbase)
}

# Solace OM3 does not specify head tube length. This can be
# computed using specs of Whisky MCX fork assuming this is
# the fork used to spec wheelbase
head_tube_length <- function(axle_crown, rake, stack, wheelbase){
  rake_h <- get_rake_h(geobike[, fork_offset_rake],
                       geobike[, head_tube_angle])
  fork_angle <- get_fork_angle(geobike[, fork_offset_rake],
                               geobike[, fork_axle_crown],
                               geobike[, head_tube_angle])
}

# Vagabond Genesis does not specify chainstay length.
get_chainstay_length <- function(rake, reach, stack, wheelbase,
                                 hta, htl, bbd){
  head_tube_h <- get_ht_h(hta, htl)
  head_tube_v <- get_ht_v(hta, htl)
  fork_v <- stack -  bbd -
    head_tube_v
  
  fork_h1 = fork_v/tan(deg_2_rad(hta))
  rake_h <- get_rake_h(rake,
                       hta)
  chainstay_h <- wheelbase - reach - head_tube_h - fork_h1 - 
    rake_h
  
  chainstay <- sqrt(chainstay_h^2 + bbd^2)
  
  return(chainstay)
}

get_fork_offset <- function(stack, reach, head_tube_angle, chainstay_length, bottom_bracket_drop, wheelbase){
  # steer_axis_h is base of triangle from top-head-tube to vertex created by steering axis and wheelbase.
  # tan hta <- stack/steer_axis_h
  steer_axis_v <- stack - bottom_bracket_drop
  steer_axis_h <- steer_axis_v /
    tan(deg_2_rad(head_tube_angle))
  chainstay_h <- get_chainstay_h(chainstay_length,
                                 bottom_bracket_drop)
  rake_h <- wheelbase - chainstay_h - reach - steer_axis_h
  rake <- rake_h * sin(deg_2_rad(head_tube_angle))
  return(rake)
}

get_effective_top_tube_length <- function(stack,
                                          reach,
                                          seat_tube_angle){
  # amigo bug out is missing this
  #
  seat_h <- stack/tan(deg_2_rad(seat_tube_angle))
  effective_top_tube_length <- seat_h + reach
  return(effective_top_tube_length)
}
```

## geometery checker

```{r}
geom_checker <- function(chainstay_length, # chainstay length
                         bottom_bracket_drop, # bottom bracket drop
                         reach,
                         stack,
                         head_tube_angle, # head tube angle
                         rake, # head tube length
                         wheelbase){ # wheelbase
  # do all the horizontal components add to wheelbase?
  chainstay_length_h <- get_chainstay_h(chainstay_length,
                                        bottom_bracket_drop)
  steer_axis_v <- stack - bottom_bracket_drop
  steer_axis_h <- steer_axis_v /
    tan(deg_2_rad(head_tube_angle))

  rake_h <- get_rake_h(rake,
                       head_tube_angle)
  wheelbase_computed <- chainstay_length_h + reach +
    steer_axis_h + rake_h

  }
```
